<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/iron-image/iron-image.html">

<link rel="import" href="./interlocutor-reply.html">
<link rel="import" href="./interlocutor-helper-behavior.html">
<link rel="import" href="./interlocutor-sdk-behavior.html">

<dom-module id="interlocutor-comment">
  <template>
    <style>
      :host {
/*        display: flex;
        flex-direction: column;
        max-height: 20em;*/
      }
      .comment-children {
        margin-left: 2em;
      }
      #commentBody {
        margin-left: 1.6em;
        margin-top: 0.4em;
      }
      #commentBodyText {
        background: #FFF4CD;
      }
      #commentRowOne {
        display: flex;
        flex-direction: row;
        justify-content: flex-start;
        align-items: center;
      }
      .comment-posted-at {
        color: #939393;
      }
      .edit-icon {
        height: 2em;
        width: 2em;
      }
      .flagged {
        color: red;
      }
      paper-icon-button[icon="star"] {
        color: #FFD600;
      }

      .comment-author-name {
        cursor: pointer;
      }

    </style>
    <div class='comment-row1-wrapper'>
      <div class='comment-body-wrapper collapse-comment'>
        <div id="commentRowOne">
          <template is="dom-if" if="[[commentBodyOpen]]">
            <iron-image src="[[avatarUrl]]" style="width:1.8em; height:1.8em" sizing="contain" preload fade></iron-image>
          </template>
          <span class='comment-author-name' on-tap="openAuthorProfile">[[commentAuthor]]</span>
          <span class='comment-posted-at'>&nbsp[[postedAt(comment.origin_server_ts, editedTimestamp)]]</span>
          <template is="dom-if" if="[[canUpVote]]">
            <paper-icon-button
              class='upvote-comment'
              icon$="[[_classBinding(upVoted, 'star', 'star-border')]]"
              on-tap="toggleUpVote">
            </paper-icon-button>
          </template>
          <template is="dom-if" if="[[canEdit]]">
            <span>
              <paper-icon-button
                icon='create'
                class="edit-icon"
                on-tap="openEditOverlay">
              </paper-icon-button>
            </span>
          </template>
          <template is="dom-if" if="[[canFlag]]">
            <span>
              <paper-icon-button
                icon='flag'
                class$="[[_classBinding(isFlagged, 'flagged')]]"
                id="flagIcon"
                on-tap="toggleFlag">
              </paper-icon-button>
            </span>
          </template>
          <!-- First Alternative -->
          <paper-icon-button class="heading"
            aria-expanded$="[[commentBodyOpen]]"
            aria-controls="commentBodyCollapse"
            on-tap="toggleCollapse"
            icon$="[[_classBinding(commentBodyOpen, 'expand-less', 'expand-more')]]">
          </paper-icon-button>
          <template is="dom-if" if="[[!commentBodyOpen]]">
            <span>[[childrenCount]]</span>
          </template>
        </div>
        <iron-collapse id="commentBodyCollapse" tabindex="0" opened="[[commentBodyOpen]]">
          <div id='commentBody'>
            <span id='commentBodyText'>[[text]]</span>
          </div>
        </iron-collapse>
      </div>
    </div>
    <iron-collapse id="commentRowTwo" tabindex="0" opened="[[commentBodyOpen]]">
      <div class='comment-row2-wrapper'>
        <template is="dom-if" if="[[canReply(userId, comment)]]">
          <paper-button class='comment-reply' on-tap="openReplyOverlay">reply</paper-button>
        </template>
        <!-- <template is="dom-if" if="[[replyOpen]]"> -->
        <!-- </template> -->
      </div>
      <div class='comment-children'>
        <template is="dom-repeat" items="[[children]]" as="comment">
          <interlocutor-comment id="[[comment.event_id]]" comment="[[comment]]" state="[[state]]" user-id="[[userId]]" settings-updated="[[settingsUpdated]]"></interlocutor-comment>
        </template>
      </div>
    </iron-collapse>
    <interlocutor-reply id="reply" tabindex="-1" with-backdrop></interlocutor-reply>
  </template>

  <script>
    Polymer({
      is: 'interlocutor-comment',

      behaviors: [
        InterlocutorHelperBehavior,
        InterlocutorSdkBehavior
      ],

      listeners: {
        'cancel': 'toggleReply',
        'flags-updated': '_recomputeChildrenFromEvent',
        'children-count-changed': '_recomputeChildrenCountFromEvent',
        'filtered-children-count-changed': '_recomputeChildrenCountFromEvent'
      },

      observers: [
        '_onFlagged(flagged.*)',
        '_recomputeChildren(settingsUpdated)',
        '_recomputeChildrenCount(children.*)',
        '_recomputeFilterdChildrenCount(children.*)'
      ],

      properties: {
        state: {
          type: Object,
          value: function() { return {} },
        },
        comment: {
          type: Object,
          value: function() { return {} },
          notify: true,
        },

        dataChildren: {
          type: Array,
          value: function() { return [] },
          computed: "_alias(comment.children, '[]')"
        },

        children: {
          type: Array,
          value: function() { return [] },
          computed: '_children(dataChildren.*)',
        },

        childrenCount: {
          type: Number,
        },

        filteredChildrenCount: {
          type: Number,
        },

        body: {
          type: Object,
          value: function() { return {} },
          computed: "_alias(comment.content.body, '{}')"
        },

        text: {
          type: String,
          value: '',
          computed: "_alias(body.text, '')"
        },

        commentBodyOpen: {
          type: Boolean,
          value: true,
        },

        commentDate: {
          type: String,
          value: 'Edited 1 hour ago'
        },

        replyOpen: {
          type: Boolean,
          value: false,
          notify: true,
        },

        userId: {
          type: String,
          value: null,
          notify: true
        },

        canEdit: {
          type: Boolean,
          value: false,
          computed: '_canEdit(userId, comment)'
        },

        canFlag: {
          type: Boolean,
          value: false,
          computed: '_canFlag(userId, comment)'
        },

        canUpVote: {
          type: Boolean,
          value: false,
          computed: '_canUpVote(userId, comment)'
        },

        flagged: {
          type: Object,
          computed: "_alias(comment.flagged, '{}')"
        },

        voted: {
          type: Object,
          computed: "_alias(comment.voted, '{}')"
        },

        isFlagged: {
          type: Boolean,
          value: false,
          computed: '_isFlagged(flagged.*, userId)'
        },

        upVoted: {
          type: Boolean,
          value: false,
          computed: '_upVoted(voted.*, userId)'
        },

        commentAuthor: {
          type: String,
          value: '',
          computed: '_commentAuthor(settingsUpdated)'
        },

        avatarUrl: {
          type: String,
          value: '',
          computed: '_avatarUrl(commentAuthor)'
        },

        editedTimestamp: {
          type: Number,
          value: null,
          computed: '_alias(comment.editedTimestamp)'
        }
      },

      openAuthorProfile() {
        this.fire('open-author-profile', this.commentAuthor)
      },

      _recomputeChildrenCountFromEvent(event, source) {
        if (source !== this) {
          // console.log('_recomputeChildrenCountFromEvent', event)
          event.preventDefault()
          this._recomputeChildrenCount()
        }
      },

      // TODO Fix this spammy recompute
      _recomputeChildrenCount(force) {
        const count = this.children.reduce((prev, cur) => {
          return prev + (cur.childrenCount || 0)
        }, 1)
        if (this.childrenCount !== count || force) {
          this.comment.childrenCount = this.childrenCount = count
          this.fire('children-count-changed', this, { cancellable: true })
        }
      },

      _recomputeFilterdChildrenCountFromEvent(event, source) {
        if (source !== this) {
          // console.log('_recomputeChildrenCountFromEvent', event)
          event.preventDefault()
          this._recomputeFilterdChildrenCount()
        }
      },

      // TODO Axe this too
      _recomputeFilterdChildrenCount(force) {
        const count = this.dataChildren.reduce((prev, cur) => {
          return prev + (this.permitted(cur) ? (cur.filteredChildrenCount || 0) : (cur.children.length) + 1)
        }, 0)
        if (this.filteredChildrenCount !== count || force) {
          this.comment.filteredChildrenCount = this.filteredChildrenCount = count
          this.fire('filtered-children-count-changed', this, { cancellable: true })
        }
      },

      attached() {
        this._recomputeChildrenCount(true)
        this._recomputeFilterdChildrenCount(true)
        this.comment.children.addListener(this, 'dataChildren')
      },

      dettached() {
        this.comment.children.removeListener(this, 'dataChildren')
      },

      _recomputeChildren(_) {
        // Because Polymer has no hard recompute
        this._pathEffector('dataChildren.*', this.dataChildren)
      },

      _recomputeChildrenFromEvent(event, source) {
        // Because fire goes to back to itself by default...
        if (source !== this) {
          // console.log('_recomputeChildrenFromEvent', this)
          event.preventDefault()
          // Because Polymer has no hard recompute
          this._pathEffector('dataChildren.*', this.dataChildren)
        }
      },

      _onFlagged() {
        console.log('firing flags-updated', this)
        this.fire('flags-updated', this, { cancellable: true })
      },

      _avatarUrl(author_id) {
        return author_id ? client.mxcUrlToHttp(client.getUser(author_id).avatarUrl) : ''
      },

      _commentAuthor() {
        return this.comment.user_id || this.comment.sender
      },

      _upVoted() {
        const vote = this.comment.voted[this.userId]
        return !!(vote && vote.content.body.value === 1)
      },

      _isFlagged(_) {
        // Note this is recomputed any time children are filtered since the comment object which
        // holds the data state is re-attached to a newly created album.
        return !!this.flagged[this.userId]
      },

      toggleUpVote() {
        // A downvote sends a -1, an Upvote a +1
        // an un - UpVote or un-DownVote a 0
        // Currently only UpVote(*Star*) supported
        this.sendVoteComment(this.comment.event_id, this.upVoted ? 0 : 1)
      },


      toggleFlag() {
        this.sendFlagComment(this.comment.event_id, !this.isFlagged).then((_ret) => {
        }, (error) => {
          console.log(error)
          // this.flagged = !this.flagged
        })
      },

      _text() {
        return this.body.text
      },


      _children(_) {
        console.log('filtering _children')
        return this.dataChildren.filter((comment) => {
          return comment.content.msgtype === 'interlocutor.comment' && this.permitted(comment)
        })
      },

      _canEdit(userId, comment) {
        return userId && comment && settings && settings.editWindow !== -1 &&
          (comment.user_id === userId) &&
          (settings.editWindow + comment.origin_server_ts < new Date().getTime())

      },

      // FIX ME
      _canUpVote(userId, comment) {
        return userId && comment // && (comment.user_id !== userId)
      },

      _canFlag(userId, comment) {
        return userId && comment // && (comment.user_id !== userId)
      },

      canReply(userId, comment) {
        return userId && comment // && (comment.user_id !== userId)
      },

      openReplyOverlay() {
        this.$.reply.targetId = this.comment.event_id
        this.$.reply.action = 'interlocutor.comment'
        this.$.reply.open()
      },

      openEditOverlay() {
        this.$.reply.targetId = this.comment.event_id
        this.$.reply.action = 'interlocutor.edit'
        this.$.reply.content = this.body.text
        this.$.reply.open()
      },

      toggleCollapse(_) {
        this.commentBodyOpen = !this.commentBodyOpen
      },

      postedAt(timestamp, editedTimestamp) {
        return editedTimestamp ? `Edited ${moment(editedTimestamp).fromNow()}`: moment(timestamp).fromNow()
      }

    });
  </script>
</dom-module>
