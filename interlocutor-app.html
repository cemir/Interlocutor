<script src="./node_modules/matrix-js-sdk/dist/browser-matrix-dev.js"></script>
<script src="./bower_components/moment/min/moment.min.js"></script>
<script src="./src/scripts.js"></script>

<link rel="import" href="./bower_components/polymer/polymer.html">
<link rel="import" href="./bower_components/paper-button/paper-button.html">
<link rel="import" href="./bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="./bower_components/paper-toast/paper-toast.html">
<link rel="import" href="./bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="./bower_components/paper-button/paper-button.html">

<link rel="import" href="./elements/interlocutor-iron-icons.html">
<link rel="import" href="./elements/interlocutor-comment.html">
<link rel="import" href="./elements/interlocutor-login.html">
<link rel="import" href="./elements/interlocutor-settings.html">
<!-- <link rel="import" href="./elements/interlocutor-author-profile.html"> -->
<link rel="import" href="./elements/interlocutor-helper-behavior.html">
<link rel="import" href="./elements/interlocutor-sdk-behavior.html">

<dom-module id="interlocutor-app">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
      }

      paper-toast {

      }

    </style>
    <template is="dom-if" if="[[!clientReady]]">
      <span hidden="[[!roomId]]">
        Comments are loading
        <paper-spinner-lite active></paper-spinner-lite>
      </span>
    </template>
    <div class='top-section'>
      <span class='user-section'>
        <template is="dom-if" if="[[userId]]">
            <span>[[userId]]</span>
            <paper-button on-tap="logout">Logout</paper-button>
        </template>
        <template is="dom-if" if="[[!userId]]">
          <paper-button on-tap="openLogin">Login to Post</paper-button>
        </template>
        <interlocutor-login id="login" tabindex="-1" with-backdrop user-id="{{userId}}" home-server-address="[[homeServerAddress]]"></interlocutor-login>
      </span>
      <span class='settings-section' hidden="[[!clientReady]]">
        <paper-icon-button on-tap="openSettings" icon="settings"></paper-icon-button>
        <interlocutor-settings id="settings" client-ready="[[clientReady]]" user-id="[[userId]]" default-settings="[[defaultSettings]]" config=[[config]] home-server-address=[[homeServerAddress]] tabindex="-1" with-backdrop></interlocutor-settings>
        [[_filteredChildrenCountStatement(filteredChildrenCount)]]
      </span>
      <!-- <interlocutor-author-profile id="authorProfile"></interlocutor-author-profile> -->
    </div>
    <paper-toast id="toast" text="" vertical-align="top"></paper-toast>
    <div class='comment-section' hidden="[[!clientReady]]">
      <template is="dom-if" if="[[_canReply(userId, roomId)]]">
        <paper-button on-tap="openReplyOverlay">Add Comment</paper-button>
      </template>
      <template is="dom-repeat" items="[[topLevelComments]]" as="comment">
        <interlocutor-comment id="[[comment.event_id]]" comment="[[comment]]" state="[[state]]" user-id="[[userId]]" settings-updated="[[settingsUpdated]]"></interlocutor-comment>
      </template>
      <interlocutor-reply id="reply" tab tabindex="-1" with-backdrop></interlocutor-reply>
    </div>
  </template>

<script>
  Polymer({
    is: 'interlocutor-app',

    behaviors: [
      InterlocutorSdkBehavior,
      InterlocutorHelperBehavior
    ],

    listeners: {
      'notify': 'notify',
      'settings-updated': '_touchSettingsUpdated',
      'logged-in': 'onLoggedIn',
      'filtered-children-count-changed': '_recomputeFilteredChildrenCountFromEvent',
      'open-author-profile': 'openAuthorProfile',
      'ignore-user': '_ignoreUser'
    },

    observers: [
      'initializeRoom(roomId)'
    ],

    properties: {
      // Default Settings are declared here so as to faciliate passing
      // a custom defaultSettings object
      defaultSettings: {
        type: Object,
        value() { return this._defaultSettings() }
      },

      config: {
        type: Object,
        value() { return this._defaultConfig() }
      },

      homeServerAddress: {
        type: String,
      },

      roomId: {
        type: String,
        value: null,
      },

      // room: {
      //   type: Object,
      //   value: null
      // },

      state: {
        type: Object,
        value: function() { return {} },
        notify: true,
      },

      users: {
        type: Object,
        value: function() { return {} },
        notify: true,
      },

      dataTopLevelComments: {
        type: Array,
        value: function() { return [] },
      },

      topLevelComments: {
        type: Array,
        value: function() { return [] },
        computed: '_topLevelComments(dataTopLevelComments.*, settingsUpdated)'
      },

      commentCount: { // TODO: unusued atm
        type: Number,
        value: 0
      },

      filteredChildrenCount: {
        type: Number,
        value: 0,
      },

      user: {
        type: Object,
        value: function() { return {} }
      },

      userId: {
        type: String,
        value: null,
      },

      settingsUpdated: {
        type: Number,
        value: null,
        notify: true
      },

      clientReady: {
        type: Boolean,
        value: false,
      },

      loggedIn: {
        type: Boolean,
        notify: true
      }
    },

    attached() {
      this.initializeClient()
    },

    initializeClient() {
      this.createClientAndLogin(null, null, this.homeServerAddress).then((success) => {
        this.loggedIn = true
      })
    },

    openAuthorProfile() {
      this.$.authorProfile.open()
    },

    _ignoreUser(event, target) {
      this.$.settings.addIgnoredIdentity(target)
    },

    _recomputeFilteredChildrenCountFromEvent(event, source) {
      event.preventDefault()

      this.filteredChildrenCount = this.dataTopLevelComments.reduce((prev, cur) => {
          return prev + (this.permitted(cur) ? (cur.filteredChildrenCount || 0) : (cur.filteredChildrenCount) + 1)
        }, 0)
    },

    _filteredChildrenCountStatement(filteredCommentsCount) {
      if (filteredCommentsCount == 1) {
        return "1 Comment hidden by filters."
      } else if (filteredCommentsCount > 1) {
        return `${filteredCommentsCount} Comments hidden by filters.`
      }
      return ""
    },

    initializeRoom(_) {
      const roomId = this.roomId
      if (!roomId) return
      // debbounce if client is not loggedIn yet
      if (!window.client || !client._http.opts.accessToken) {
        return this.debounce('initialize-room', this.initializeRoom.bind(this), 300)
      }
      // window.room = this.room = client.getRoom(this.roomId)
      window.roomId = this.roomId
      // debounce if the room create event hasn't been processed yet
      if (!this.roomId) {
        return this.debounce('initialize-room', this.initializeRoom.bind(this), 300)
      }
      this.state[this.roomId] = { children: new NotifyArray() }
      this.initializeComments()
    },

    onLoggedIn(userId) {
      this.loggedIn = true
      if (this.roomId && !client.isGuest()) {
        client.joinRoom(this.roomId)
      }
    },

    initializeComments() {
      try {
        client.on("Room.timeline", (matrixEvent, room, toStartOfTimeline) => {
          const event = matrixEvent.event
          console.log('received Room.timeline event', event.event_id, event.type, room.room_id)
          this.processEvent(event)
        })
        this.buildInitialRoomState(this.roomId).then((_) => {
          this.clientReady = true
          // FIX THIS ALSO
          this.dataTopLevelComments = this.state[this.roomId].children
          this.dataTopLevelComments.addListener(this, 'dataTopLevelComments')
        }, (err) => {
          console.log(err)
        })
      } catch (e) {
        console.log(e)
      }
    },

    _hasComments(dataTopLevelComments, clientReady) {
      return dataTopLevelComments && dataTopLevelComments.length || !clientReady
    },

    _touchSettingsUpdated() {
      // TODO switch to _pathEffector
      // Really should be public API for forcing re-computes in Polymer..
      console.log('_touchSettingsUpdated')
      this.settingsUpdated += 0.1
    },

    _topLevelComments() {
      console.log('_topLevelComments')
      return this.dataTopLevelComments.filter((comment) => {
        return comment.content.msgtype === 'interlocutor.comment' && this.permitted(comment)
      })
    },

    logout() {
      this.loggedIn = false
      this.createClientAndLogin(null, null, this.homeServerAddress, true).then((success) => {
        this.userId = null
      })
    },

    _credentials() {
      return client.credentials
    },

    toggle(selector) {
      this.commentBodyOpen = !this.commentBodyOpen
    },

    openLogin() {
      this.$.login.open()
    },

    openSettings() {
      this.$.settings.open()
    },

    notify(event) {
      this.$.toast.text = event.detail
      this.$.toast.open()
    },

    openReplyOverlay() {
      this.$.reply.targetId = this.roomId
      this.$.reply.action = 'interlocutor.comment'
      this.$.reply.open()
    },

    _canReply(userId, roomId) {
      return userId && roomId
    }
  });
</script>
</dom-module>
